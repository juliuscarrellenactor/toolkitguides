# Application View

## The Application View

Application Processes provide for Process Level State Data in a scope shared by all States within the Process, each of which includes State Data that is available only to Actions that execute within the scope of the State. Similarly, the executing Application has a **View**, which is established by the Runtime Framework when the Application is started. It stores ***View Level Data*** in a scope shared by all Process of the Application and accessible using ***UISetViewDataAction*** and ***UIGetViewDataAction***. The Application View also has an ***Event Queue***, which corresponds to the Application UI Thread of the Java Runtime. State and UI Events generated within a State are received and processed directly from this Event Queue. ***View Events***, which can be created in Application Processes are also posted to this Event Queue and are processed by the View, relaying them directly to all States that are set to ***Respond to View Events***.

By this means, parallel executing Processes that *Execute in Background* or *Execute in Window*, are able to communicate by sending and responding to View Events and accessing shared View Level Data.

## View Events

The Event types discussed so far have been ***State Events***, which are generated by the Class that implements the State functionality. State Events, most conspicuously the button events generated by Prompt States, must be identified in the Events list of the State Icon, although they may be flagged as *Unused*. In all cases however, whether flagged *Unused* or not, State Events must be intercepted if generated and responded to by the State. If the underlying class generates the event and it is not handled by the State (by a Process Flow) an Exception will occur. 

Processes may generate ***View Events*** using the **Send Event** Action, which are always intercepted in the first instance by the View and relayed to all States within the View that are registered as listeners. States are registered as listeners if configured at Design time to *Respond to View Events* by setting this property to *true*. All registered State listeners receive all View Events. If there are no State Listeners, the Event will be ignored. If a State receives a View Event and the Event is not listed in the State Icon with a Process Flow to handle it, the event will be ignored. Unlike the case with State Events, View Events may be raised and go unhandled without an Exception being thrown.

## Communication Between Application Processes

When Application Proceses are executed in separate threads or pseudo-threads using the *Execute in Background* or *Execute in Window* Actions, respectively, there may be a Design requirement for communication between them. This is achieved by exchange of Data and Events via the View.

### **Send Event Action**

A Background Process (or any other Process) may at any time (and potentially multiple times) issue a Designernamed Event using the **Send Event** Action, for which the Event Name is an Input Data Item. Other Designer-named Inputs may also be specified, which are essentially relayed with the Event to the Event target and will populate its corresponding State Data Items. All Events are processed *via* States and if handled, are always handled as a Process Flow from the Event as listed among the State Events.

All registered listener States receive View Events. However, it is typically designed into an Application Process to respond to the arrival of expected, named Events in a specific State (or States).

### **View Event Processing**

Processing of a View Event depends on the following:

- The presence of a State having the property ***Respond to View Events?*** set to *true*.
  If this is not the case the Event is destroyed unprocessed.
- The arrival of the Event to a State
  The event waits in the Event Queue until this occurs.
- The State at which the Event arrives also having the designernamed Event declared as an Event that it responds to. If this is not the case the Event is destroyed unprocessed 
  (**note** that unlike Prompt Events, View Events do not generate an error if unprocessed).
- The State at which the Calling Process arrives also having State Data Items corresponding in name to the Input Items of the Send Event Action. 
  If this is not the case the Input Data Items are destroyed unprocessed.
### **View Event Constraints**

Background Process (initiated by *Execute in Background*) may generate View Events using the Send Event Action. However, States within Background Process cannot listen for View Events and should never be set to *Respond to View Events*, nor can they use UI Prompts, which are not thresdsafe with the Main UI Thread. Background Process initiated by *Execute in Window* by contrast, may both generate and respond to View Events and may also, independently process UI using Prompt States.
**Note** that Applications may create multiple Views. This topic is out of scope for this book. However, if the ***EventForwardAllViews*** Input flag of the ***Send Event*** Action is set *true,* the Event is relayed by *all* Views to their listener states. 

### **Close View**

The Close View Action is not a Tools Palette option but may be dragged from the Enactor Tools Resource Library, which is discussed in later sections and more fully in Chapter 23. The View provides context for the main Process of the Application and the Close View Action should be invoked prior to exit from the Application. Note that a Close View Action is required in the specified *Execute Process ID* of an *Execute Process* Action since the Process that executes this Action will cease to exist.

#### *UICloseViewAction*

![Graphical user interface, application Description automatically generated](./Images/Aspose.Words.c588f332-4d17-46a2-bd69-c921daed5fe0.001.png)|**Description** The UICloseViewAction closes the current View. Closing the current View effectively terminates the Application. Inputs None. Outputs None. Outcomes Success if the current View is successfully closed. Usage Notes None.

### **Stop Linking**

The *UIStopLinkingAction* is not a Tools Palette option but may be dragged from the Resource Library. It stops execution of the Process Flow without termination the Process or returning any sort of Outcome. It can be used with Prompts that return often to perform functions and then terminate without closing the Prompt.  

## Stopping a Background Process

When a single Background Process Thread is created using the *Execute in Background* Action a ***ProcessHandle*** Output Data Item is obtained, on initiation of the single thread. The *ProcessHandle* Output Item must be of type *com.enactor.coreUI.processes.**IUIProcessHandle*** and may be used as Input to a ***UIStopBackgroundProcess*** Action to terminate the thread.
#### *UIStopBackgroundProcessAction*


![Graphical user interface, text, application Description automatically generated](./Images/Aspose.Words.c588f332-4d17-46a2-bd69-c921daed5fe0.002.png)**Description**The UIStopBackgroundProcessAction terminates the specified background Process.Inputs ProcessHandle Identifier of the Background Process to be terminated, which must be of type com.enactor.coreUI.processes.IUIProcessHandle, the corresponding type of the Output Item enactor.coreUI.ProcessHandle of the Execute in Background Action. Outputs None. Outcomes Success if the background Process is successfully terminated. Usage Notes None.




